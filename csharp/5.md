| No. | Topic                                                                                               |
| --- | --------------------------------------------------------------------------------------------------- |
| 1   | [Collections and Generics](#collections-and-generics)                                               |
| 2   | [Collections](#collections)                                                                         |
| 3   | [List<T> Collection](#listt-collection)                                                             |
| 4   | [Dynamically Resizing a List<T> Collection](#dynamically-resizing-a-listt-collection)               |
| 5   | [Collection Initializers](#collection-initializers)                                                 |
| 6   | [Collection Interfaces](#collection-interfaces)                                                     |
| 7   | [Creating Indexers](#creating-indexers)                                                             |
| 8   | [Indexers and Assignment](#indexers-and-assignment)                                                 |
| 9   | [Indexing on Other Values](#indexing-on-other-values)                                               |
| 10  | [Generics](#generics)                                                                               |
| 11  | [Generic Collection Interfaces](#generic-collection-interfaces)                                     |
| 12  | [Interface Purpose](#interface-purpose)                                                             |
| 13  | [The IEnumerable<T> Interface](#the-ienumerablet-interface)                                         |
| 14  | [Framework Generic Collections](#framework-generic-collections)                                     |
| 15  | [Generic Lists: List<T>](#generic-lists-listt)                                                      |
| 16  | [Aside – The Random Class](#aside-–-the-random-class)                                               |
| 17  | [Sorting Objects with the Generic List](#sorting-objects-with-the-generic-list)                     |
| 18  | [Controlling Sorting by Implementing IComparer<T>](#controlling-sorting-by-implementing-icomparert) |
| 19  | [Generic Queues](#generic-queues)                                                                   |
| 20  | [Generic Stacks](#generic-stacks)                                                                   |
| 21  | [Stack methods and properties](#stack-methods-and-properties)                                       |
| 22  | [Dictionaries](#dictionaries)                                                                       |

# Collections and Generics

## Collections

- Arrays are useful with a group of objects of the same type that need to be
  treated as a group or a collection
- Arrays are the simplest collection but are probably the least flexible of the
  standard collections
- Must define the array size when created
- The five most commonly used collection classes are:
  - Array
  - List
  - Stack
  - Queue
  - Dictionary
- The .NET Framework Class Library provides several classes, called collections,
  used to store groups of related objects.
- These classes provide efficient methods that organize, store and retrieve your
  data without requiring knowledge of how the data is being stored.

## `List<T>` Collection

- The generic collection class `List<T>` (from namespace
  `System.Collections.Generic`) does not need to be reallocated to change its
  size.
- `List<T>` is called a generic class because it can be used with any type of
  object.
- `T` is a placeholder for the type of the objects stored in the list.

## Dynamically Resizing a `List<T>` Collection

- The `Count` property returns the number of elements currently in the List.
- The `Capacity` property indicates how many items the List can hold without
  having to grow.
  - When the List is created, both are initially 0 though the `Capacity` is
    implementation dependent.
- The `Add` method appends its argument to the end of the List.
- The `Insert` method inserts a new element at the specified position.
  - The first argument is an index as with arrays, collection indices start at
    zero.
  - The second argument is the value that's to be inserted at the specified
    index.
  - The indices of elements at the specified index and above increase by one.
- Lists can be indexed like arrays by placing the index in square brackets after
  the List variable's name.
- The `Remove` method is used to remove the first instance of an element with a
  specific value.
  - If no such element is in the List, Remove does nothing.
- `RemoveAt` removes the element at the specified index.
  - The indices of all elements above that index decrease by one.
- The `Contains` method returns `true` if the element is found in the List, and
  `false` otherwise.
  - Contains compares its argument to each element of the List in order, so
    using `Contains` on a large List is inefficient.
  - When the List grows, it must create a larger internal array and copy each
    element to the new array.
- A List grows only when an element is added and there is no space for the new
  element.
- Doubling a List's Capacity is an efficient way for a List to grow quickly to
  be "about the right size."
- This operation is much more efficient than growing a List by only as much
  space as it takes to hold the elements) being added.
- A disadvantage is that the List might occupy more space than it requires.
- This is a classic example of the spaceltime trade-off.
- It can be wasteful to double a List's size when more space is needed.
- For example, a full List of 1,000,000 elements resizes to accommodate
  2,000,000 elements when one new element is added.
- This leaves 999,999 unused elements.
- You can use `TrimExcess` (as in `yourListObject.TrimExcess()`) to reduce a
  List's Capacity to its current Count.
- You also can set the Capacity directly to control space usage better for
  example, if you know a List will never grow beyond 100 elements, you can
  preallocate that space by assigning 100 to the List's Capacity or using the
  List constructor that receives an initial capacity.
- The string method `ToUpper` to converts a string to uppercase.
- The string method `StartsWith` performs a case sensitive comparison to
  determine whether a string starts with the string received as an argument.

## Collection Initializers

- Collection initializers provide a convenient syntax (similar to array
  initializers) for initializing a collection
  ```cs
  var items = new List<string> {"aQua", "RusT", "yElLow", "rEd"};
  ```
- Explicitly creates the `List<string>` with new, so the compiler knows that the
  initializer list contains elements for a `List<string>`
- The following declaration would generate a compilation error, because the
  compiler cannot determine whether you wish to create an array or a collection
  ```cs
  var items = {"aQua", "RusT", "yElLow", "rEd"};
  ```

## Collection Interfaces

- The .NET Framework provides a number of interfaces, such as IEnumerable and
  ICollection, which the designer of a collection must implement to provide full
  collection semantics
- IEnumerable allows a collection to be enumerated in a foreach loop
- The goal in creating a collection is to make them similar to the standard .NET
  collections as much as possible
- This reduces confusion, and makes for easier-to-use classes and
  easier-to-maintain code

## Creating Indexers

- One feature that should be provided is to allow users of the collection to add
  or to extract from the collection with an indexer similar to an array
- Suppose a ListBox control named myListBox contains a list of strings stored in
  a one-dimensional array as a private member variable named myStrings
- A ListBox control contains member properties and methods in addition to its
  array of strings, so the ListBox itself is not an array
- It would be convenient to be able to access the ListBox array with an index
  just as though it were an array
- An indexer is a construct that allows the class to be treated as though it
  were an array

```cs
string theFirstString = myListBox[0];
string theLastString = myListBox[Length-1];
```

- An indexer is a special kind of property but like all properties, it has get
  and set accessors
- An indexer property is declared within a class:
  `type this [type argument] {get; set;}`
- For example:

```cs
public string this[int index] {
    get { /* ... */ };
    set { /* ... */ };
}
```

- The return type determines the type of object returned by the indexer
- The type argument specifies what kind of argument will be used to index into
  the collection containing the target objects
- It is common to use integers as index values, but other types can be used as
  well, such as strings
- An indexer can be provided with multiple parameters to create a
  multidimensional array
- The this keyword is a reference to the object in which the indexer appears
- get and set must also be defined to determine how the object is retrieved from
  or assigned to its collection
- This listing ignores everything else a ListBox can do and focuses only on the
  list of strings the ListBox maintains using System.Collections.Generic;

```cs
// a simplified ListBox control
public class ListBoxTest {
    private string[] strings; // maintain a list of strings

    // keep track of how many strings in the array
    private int ctr = 0;

    // initialize the ListBox with strings
    public ListBoxTest(params string[] initialStrings) {
        // allocate space for the strings
        strings = new String[256];

        // copy the strings passed in to the constructor
        foreach (string s in initialStrings) {
            strings[ctr++] = s;
        }
    }

    // add a single string to the end of the ListBox
    public void Add(string theString) {
        if (ctr >= strings.Length) {
            // handle bad index
        } else {
            strings[ctr++] = theString;
        }
    }

    // publish how many strings you hold
    public int GetNumEntries() {
        return ctr;
    }

    // allow array-like access
    // the syntax of the indexer is very similar to that for properties
    public string this[int index] {
        // implement some basic bounds checking
        get {
            if (index < 0 || index >= strings.Length) {
            // handle bad index
        }
        return strings[index];
    }

    // make sure the index being set already has a value in the ListBox
    set {
        // add new items only through the Add method (illegal to try to add with set)
        if ( index >= ctr ) {
            // handle error
        } else {
            strings[index] = value;
        }
    }
}

public class Tester {
    static void Main() {
        // create a new ListBox and initialize
        ListBoxTest lbt = new ListBoxTest("Hello", "World");

        // add a few strings
        lbt.Add("Proust");
        lbt.Add("Faulkner");
        lbt.Add("Mann");
        lbt.Add("Hugo");

        // test the access by modifying the second value
        string subst = "Universe";
        lbt[1] = subst;

        // access all the strings
        for (int i = 0; i < lbt.GetNumEntries(); i++) {
            Console.WriteLine("lbt[{0}]: {1}", i, lbt[i]);
        }
    }
}
```

## Indexers and Assignment

```console
lbt[0]: Hello
lbt[1]: Universe
lbt[2]: Proust
lbt[3]: Faulkner
lbt[4]: Mann
lbt[5]: Hugo
```

- Cannot assign to an index that does not have a value

```cs
lbt[10] = "wow!";
```

- Triggers the error handler in the set accessor because the index passed in
  (10) is larger than the counter (6)

## Indexing on Other Values

- C# does not require that an integer value is always used as the index to a
  collection
- Integers are simply the most common method as they make it easier to iterate
  over the collection using a for loop
- Indexers in a custom collection class can be strings and other types
- The index value can be overloaded so that a given collection can be indexed by
  different types
- Index by an integer or by a string
- Example 14.2 is identical to except for the addition of an overloaded indexer,
  which can match a string, and the method FindString, created to support that
  index

```cs
// This method iterates through the strings held in MyStrings until it finds a
// string that starts with the target string used in the index
private int FindString(string searchString) {
    for (int i = 0; i < strings.Length; i++) {
        if (strings[i].StartsWith(searchString)) {
            return i; // if found, return the index of the string
        }
    }

    // if not found, return -1
    return -1;
}

// index on string
public string this[string index] {
    get {
        // handle bad index
        if (index.Length == 0) {
            return this[FindString(index)];
        }
    }
    set {
        // no need to check the index here because
        // find string will handle a bad index value
        strings[FindString(index)] = value;
    }
}

public class Tester {
    static void Main() {
        // create a new ListBox and initialize
        ListBoxTest lbt = new ListBoxTest("Hello", "World");

        // add a few strings
        lbt.Add("Proust");
        lbt.Add("Faulkner");
        lbt.Add("Mann");
        lbt.Add("Hugo");

        // test the access
        string subst = "Universe";
        lbt[1] = subst;

        // string segment as the index instead of an int
        lbt["Hel"] = "GoodBye";

        // this would return index -1, causing exception
        // lbt["xyz"] = "oops";

        // access all the strings
        for (int i = 0; i < lbt.GetNumEntries(); i++) {
            Console.WriteLine("lbt[{0}]: {1}", i, lbt[i]);
        }
    }
}
```

## Output

```console
lbt[0]: GoodBye
lbt[1]: Universe
lbt[2]: Proust
lbt[3]: Faulkner
lbt[4]: Mann
lbt[5]: Hugo
```

- If a string does not match, a value of -1 is returned, which is then used as
  an index into MyStrings
- This generates a `System.NullReferenceException, lbt["xyz"] = "oops";`

## Generics

- Before generics, all collection classes (only ArrayList, Stack, Queue at that
  time) were defined to hold objects of type Object
- Could add integers and strings to the same collection
- Had to be cast to their "real" type when taken out of the collection
- This was ugly and error-prone
- With generics, the designer of the class (i.e., Stack) can say "This class
  will hold only one type, and that type will be defined by the developer who
  makes an instance of this class"
- The user of the generic Stack class defines an instance of the Stack and the
  type it will hold
- The compiler can now enforce that only objects of the designated type are
  stored in the collection
- This is known as type-safety
- This is important as often a collection is used polymorphically
- If there's a stringin a collection of ints, there may be a surprise should
  each item be divided by 2
- The designer adds a type placeholder (type parameter), which is usually
  represented by the letter T in angle brackets: `class Stack<T>`
- The user of the Stack class puts in the actual type when instantiating the
  class:

```cs
Stack<Employee> = new Stack<Employee>
```

## Generic Collection Interfaces

- The .NET Framework provides standard interfaces for enumerating and comparing
  collections
- These standards interfaces are type-safe, but the type is generic
- Can declare an ICollection of any type by substituting the actual type (int,
  string, or Employee) for the generic type in the interface declaration (`<T>`)
- If creating an interface called IStorable but the kinds of objects that would
  be stored is unknown:

```cs
interface IStorable<T> {
    // method declarations here
}
```

- Later on, if a new class, Document, were created that implemented IStorable to
  store strings:

```cs
public class Document: IStorable<String>
```

- Replacing T with the type to apply the interface to
- The creator of the class says, "This applies to some type `<T>` to be named
  later (when the interface or class is used) and the programmer using the
  interface or collection type replaces `<T>` with the actual type (for example,
  int, string, Employee, and so on)"

## Interface Purpose

| Interface                          | Purpose                                                       |
| ---------------------------------- | ------------------------------------------------------------- |
| ICollection<T>                     | Base interface for generic collections                        |
| IEnumerator<T> <br> IEnumerable<T> | Required for collections that will be enumerated with foreach |
| IComparer<T> <br> IComparable<T>   | Required for collections that will be sorted                  |
| IDictionary<K,V>                   | Used for key/value-based collections                          |
| IList<T>                           | Used by indexable collections                                 |

## The `IEnumerable<T>` Interface

- The foreach statement can be supported in ListBoxTest by implementing the
  `IEnumerable<T>` interface
- IEnumerable has only one method, GetEnumerator(), whose job is to return an
  implementation of `IEnumerator<T>`
- C# provides special help in creating the enumerator, using the keyword yield
- Making the ListBox an enumerable class requires implementing the
  `IEnumerable<T>` interface

```cs
public class ListBoxTest : IEnumerable<String> {
    private string[] strings;
    private int ctr = 0;

    // Enumerable classes return an enumerator
    public IEnumerator<string> GetEnumerator() {
        foreach (string s in strings) {
            yield return s;
        }
    }

    // required to fulfill IEnumerable
    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
        throw new NotImplementedException();
    }

    // include all previous methods of ListBoxTest
}

public class Tester {
    static void Main() {
        // create a new ListBox and initialize
        ListBoxTest lbt = new ListBoxTest("Hello", "World");

        // add a few strings
        lbt.Add("Proust");
        lbt.Add("Faulkner");
        lbt.Add("Mann");
        lbt.Add("Hugo");

        // test the access
        string subst = "Universe";
        lbt[1] = subst;

        // access all the strings
        foreach (string s in lbt) {
            if (s == null) break;
            Console.WriteLine("Value: {0}", s);
        }
    }
}
```

## Output

```console
Value: Hello
Value: Universe
Value: Proust
Value: Faulkner
Value: Mann
Value: Hugo
```

- As in the previous example, a new ListBoxTest object is created with an array
  of six strings
- The big change in this version is that a foreach loop is called, retrieving
  each string in the ListBox
- The loop looks simple, but it's complicated behind the scenes
- To work properly, it needs a reference to an `IEnumerator<T>`
- Because of the `IEnumerable<T>` interface though, the method GetEnumerator()
  returns a reference to an `IEnumerator<T>`
- The foreach loop automatically uses the interface, `IEnumerable<T>`, invoking
  GetEnumerator()
- The GetEnumerator() method returns an IEnumerator of type string
- The implementation iterates through the array of strings, yielding each in
  turn
- Keyword yield is used explicitly to return a value to the enumerator object
- By using yield, all of the bookkeeping for keeping track of which element is
  next, resetting the iterator, and so forth is provided by the framework
- The method just shown is for the generic `IEnumerator<T>` interface
- Note that there is also an implementation of the nongeneric GetEnumerator()
  method
- This is required by the definition of the generic `IEnumerable<T>`
- Even though it's required to be there, it won't be used, and so it's typically
  defined to just throw an exception, since it isn't expected to be called
- Basically, this is just a way of saying, "Don't use this method. If you do use
  this method, something has gone wrong."
- The difference between the last two examples is just the foreach loop, but
  that means the ListBoxTest class needs to implement `IEnumerable<T>`, which in
  turn means it has to implement both the generic and the nongeneric versions of
  GetEnumerator()
- It may seem like a lot of effort just to make foreach work and it may not seem
  like it's worth it
- The framework collections all support foreach
- All that extra work is hidden making it seem like a simple loop
- To work like the framework collections, foreach must be supported as well
- Luckily, `IEnumerable<T>` and yield do a lot of the work

## Framework Generic Collections

- What generic collections are and how they work has been explained in the last
  few examples
- How they're created and what they can do can be appreciated now
- Most of the time, creating a new collection will not be necessary, because the
  .NET Framework provides four very useful generic collections:
  - List
  - Stack
  - Queue
  - Dictionary

## Generic Lists: `List<T>`

- The problem with the Array type is its fixed size
- Not knowing in advance how many objects an array will hold runs the risk of
  declaring it either too small (running out of room) or too large (wasting
  memory)
- The generic List class is, essentially, an array whose size is dynamically
  increased as required

| Method or Property | Purpose                                                                                                                                                                  |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Capacity           | Property to get or set the number of elements the List can contain; this value is increased automatically if count exceeds capacity                                      |
| Count              | Property to get the number of elements currently in the List                                                                                                             |
| Add()              | Public method to add an object to the List                                                                                                                               |
| AddRange()         | Public method that adds the elements of an ICollection to the end of the List                                                                                            |
| BinarySearch()     | Overloaded public method that uses a binary search to locate a specific element in a sorted List                                                                         |
| Clear()            | Removes all elements from the List                                                                                                                                       |
| Contains()         | Determines whether an element is in the List                                                                                                                             |
| CopyTo()           | Overloaded public method that copies a List to a one-dimensional array; commonly used to convert a List to an array for methods that accept only arrays, not collections |
| Exists()           | Determines whether the List contains elements that meet the specified criteria                                                                                           |
| Find()             | Returns the first List element that meets specified criteria                                                                                                             |
| FindAll()          | Returns all List elements that meet specified criteria                                                                                                                   |
| GetEnumerator()    | Overloaded public method that returns an enumerator to iterate through a List                                                                                            |
| GetRange()         | Copies a range of elements to a new List                                                                                                                                 |
| IndexOf()          | Overloaded public method that returns the index of the first occurrence of a List element                                                                                |
| Insert()           | Inserts an element into a List                                                                                                                                           |
| InsertRange()      | Inserts the elements of a collection into the List                                                                                                                       |
| LastIndexOf()      | Overloaded public method that returns the index of the last occurrence of a List element that meets the specified criteria                                               |
| Remove()           | Removes the first occurrence of a specific object                                                                                                                        |
| RemoveAt()         | Removes the element at the specified index                                                                                                                               |
| RemoveRange()      | Removes a range of elements                                                                                                                                              |
| Reverse()          | Reverses the order of elements in the List                                                                                                                               |
| Sort()             | Sorts the List                                                                                                                                                           |
| ToArray()          | Copies the elements of the List to a new array; commonly used to convert a List to an array for methods that accept only arrays, not collections                         |
| TrimExcess()       | Sets the capacity to the actual number of elements in the List                                                                                                           |

- No need to define how many objects a List will contain
- Add to the List using the Add() method, and the List takes care of its own
  internal bookkeeping

```cs
public class Employee {
    private int empID;

    // constructor
    public Employee(int empID) {
        this.empID = empID;
    }

    public override string ToString() {
        return empID.ToString();
    }
}

public class Tester {
    static void Main() {
        List<Employee> empList = new List<Employee>();
        List<int> intList = new List<int>();

        // populate the Lists
        for (int i = 0; i < 5; i++) {
            intList.Add(i * 5);
            empList.Add(new Employee(i + 100));
        }

        // print the contents of the int List
        for (int i = 0; i < intList.Count; i++) {
            Console.Write("{0} ", intList[i].ToString());
        }

        Console.WriteLine("\n");

        // print the contents of the Employee List
        for (int i = 0; i < empList.Count; i++) {
            Console.Write("{0} ", empList[i].ToString());
        }

        Console.WriteLine("\nempList.Capacity: {0}", empList.Capacity);
    }
}
```

## Output

```console
0 5 10 15 20
100 101 102 103 104
empList.Capacity: 8
```

- The `List` class has a property, `Capacity`, which is the number of elements
  the `List` is capable of storing
- This capacity is automatically increased each time the limit is reached and a
  new element needs to be added
- The `Listdoubles` its `Capacity` each time it grows
- The `Add()` method takes care of things behind the scenes
- It increases the capacity of the `List` if necessary
- It inserts the new item at the end of the `List`
- It provides the new item with an appropriate index

## Aside – The Random Class

- To create random values, instantiate class `Random`
- To cause the `Random` instance to generate random values, call its `Next()`
  method
- One version of the `Next()` method allows the largest random number desired to
  be specified
- To generate a random number from 0 to 99:

```cs
Random r = new Random();
r.Next(100);
```

- Random number generators do not technically create true random numbers
- They create **pseudorandom** numbers
- They're not completely random because a mathematical process is used to create
  them

## Sorting Objects with the Generic List

- The `List` implements the `Sort()` method
- Any `List` can be sorted if it contains objects that implement IComparable
- All the built-in types implement this interface so both a `List<int>` or a
  `List<string>` can be readily sorted
- To sort a `List<Employee>`, the `Employee` class must implement `IComparable`
- As part of the `IComparable` interface contract, the `Employee` object must
  provide a `CompareTo()` method

```cs
public int CompareTo(Employee rhs) {
    return this.empID.CompareTo(rhs.empID);
}
```

- The `CompareTo()` method takes an `Employee` as a parameter
- The `Employee` object must compare itself to the passed in second `Employee`
  object and return -1 if it is smaller, 1 if it is greater, and 0 if they are
  equal to each other
- It is up to the designer of the class to determine what smaller than, greater
  than, and equal to mean for an `Employee`
- In this example, the objects will be compared based on the value of their
  `empID` members
- As `empID` is an `int` (a built-in type) it already has its own default
  `CompareTo()` method
- The `CompareTo()` method for `Employee` just calls the `CompareTo()` method of
  `empID`

```cs
// Creates an integer list and an Employee list of random numbers and sorts them both
// a simple class to store in the list
public class Employee: IComparable<Employee> {
    private int empID;

    public Employee(int empID) {
        this.empID = empID;
    }

    public override string ToString() {
        return empID.ToString();
    }

    // Comparer delegates back to Employee
    // Employee uses the integer's default CompareTo method
    public int CompareTo(Employee rhs) {
        return this.empID.CompareTo(rhs.empID);
    }
}

public class Tester {
    static void Main() {
        List<Employee> empList = new List<Employee>();
        List<int> intList = new List<int>();

        // generate random numbers for both the
        // integers and the employee id's
        Random r = new Random();

        // populate the list
        for (int i = 0; i < 5; i++) {
            // add a random employee id
            empList.Add(new Employee(r.Next(10) + 100));

            // add a random integer
            intList.Add(r.Next(10));
        }

        // display all the contents of the int list
        Console.WriteLine("List<int> before sorting: ");
        for (int i = 0; i < intList.Count; i++) {
            Console.Write("{0} ", intList[i].ToString());
        }

        // display all the contents of the Employee list
        Console.WriteLine("\nList<Employee> before sorting: ");
        for (int i = 0; i < empList.Count; i++) {
            Console.Write("{0} ", empList[i].ToString());
        }

        // sort and display the int list intList.Sort();
        Console.WriteLine("\nList<int>after sorting: ");
        for (int i = 0; i < intList.Count; i++) {
            Console.Write("{0} ", intList[i].ToString());
        }

        // sort and display the Employee list empList.Sort();
        Console.WriteLine("\nList<Employee>after sorting: ");
        for (int i = 0; i < empList.Count; i++) {
            Console.Write("{0} ", empList[i].ToString());
        }

        Console.WriteLine("\n");
    }
}
```

## Output

```console
List<int> before sorting:
    0 4 1 6 6
List<Employee> before sorting:
    106 106 105 102 100
List<int>after sorting:
    0 1 4 6 6
List<Employee>after sorting:
    100 102 105 106 106
```

- The output shows that the lists of integers and `Employees` were generated
  with random numbers
- When sorted, the display shows that the values have been ordered properly

## Controlling Sorting by Implementing `IComparer<T>`

- The default implementation of `IComparer` is called behind the scenes when
  `Sort()` is called on the `List`
- This uses a **Quick Sort** algorithm to call the `IComparable` implementation
  of `CompareTo()` on each element in the `List`
- The programmer may create their own implementation of `IComparer`, which might
  be needed to control how the sort ordering is to be defined
- Sorts may be done either by ID or by years of service
- This can be determined at runtime
- To accomplish this, create a custom implementation of `IComparer` which will
  be passed to the `Sort()` method of `List`
- A new class will be implemented, `EmployeeComparer`, which will implement
  `IComparer` and will know how to sort `Employees`
- To simplify the programmer's ability to choose how a given set of `Employees`
  are sorted, `WhichComparison` will be a new enumeration property of type
  `Employee.EmployeeComparer.ComparisonType`
- When `EmployeeComparer` is created, it will be passed `WhichComparison`, which
  will be of type `ComparisonType`
- `ComparisonType` is an enumeration with one of two values, `empID` or
  `yearsOfSvc` indicating which field to sort by
- This may seem convoluted, but later on, if another property is added to the
  `Employee` class (lastName), it is very easy to add `LastName` to the
  enumeration to allow sorting on that field too
- Before invoking `Sort()`, an instance of `EmployeeComparer` is created, and
  its `ComparisonType` property is set
- The `EmployeeComparer` class must provide a `Compare()` method
- When `Sort()` is invoked, the `List` will call that `Compare()` method on
  `EmployeeComparer`, which in turn will delegate the comparison to the
  `Employee.CompareTo()` method, passing in its `WhichComparison` property
- The `Employee` object must implement a custom version of `CompareTo()`
- This custom method needs to accept the `Employee` object to compare to (rhs),
  and a member of the `ComparisonType` enumeration
- Depending on the value of `ComparisonType`, compare the value of either the
  `empID` or `yearsOfSvc`
- Since both are `int`s, they can just be delegated to the intversion of the
  `CompareTo()` method
- A `LastName` member would need to call the stringclass's version of
  `CompareTo()` instead

```cs
// Sorts a List by differing properties of the Employee class
public class Employee: IComparable<Employee> {
    private int empID;
    private int yearsOfSvc = 1;

    public Employee(int empID) {
        this.empID = empID;
    }

    public Employee(int empID, int yearsOfSvc) {
        this.empID = empID;
        this.yearsOfSvc = yearsOfSvc;
    }

    public override string ToString() {
        return "ID: " + empID.ToString() + ". Years of Svc: " + yearsOfSvc.ToString();
    }

    // static method to get a Comparer object
    public static EmployeeComparer GetComparer() {
        return new Employee.EmployeeComparer();
    }

    // Comparer delegates back to Employee
    // Employee uses the integer's default
    // CompareTo method
    public int CompareTo(Employee rhs) {
        return this.empID.CompareTo(rhs.empID);
    }

    // Special implementation to be called by custom comparer
    public int CompareTo(Employee rhs, Employee.EmployeeComparer.ComparisonType Which) {
        switch (Which) {
            case Employee.EmployeeComparer.ComparisonType.EmpID:
                return this.empID.CompareTo(rhs.empID);
            case Employee.EmployeeComparer.ComparisonType.YearsOfService:
                return this.yearsOfSvc.CompareTo(rhs.yearsOfSvc);
        }
        return 0;
    }

    // nested class which implements IComparer
    public class EmployeeComparer: IComparer<Employee> {
        // private state variable
        public Employee.EmployeeComparer.ComparisonType WhichComparison { get; set; }

        // enumeration of comparsion types
        public enum ComparisonType { EmpID, YearsOfService };

        // Tell the Employee objects to compare themselves
        public int Compare(Employee lhs, Employee rhs) {
            return lhs.CompareTo(rhs, WhichComparison);
        }
    }
}

public class Tester {
    static void Main() {
        List<Employee> empList = new List<Employee>();

        // generate random numbers for
        // both the integers and the
        // employee IDs
        Random r = new Random();

        // populate the list
        for (int i = 0; i < 5; i++) {
            // add a random employee ID
            empList.Add(new Employee(r.Next(10) + 100, r.Next(20)));
        }

        // display all the contents of the Employee list
        for (int i = 0; i < empList.Count; i++) {
            Console.Write("\n{0} ", empList[i].ToString());
        }

        Console.WriteLine("\n");

        // sort and display the employee list
        Employee.EmployeeComparer c = Employee.GetComparer();
        c.WhichComparison = Employee.EmployeeComparer.ComparisonType.EmpID;
        empList.Sort(c);

        // display all the contents of the Employee list
        for (int i = 0; i < empList.Count; i++) {
            Console.Write("\n{0} ", empList[i].ToString());
        }
        Console.WriteLine("\n");

        c.WhichComparison = Employee.EmployeeComparer.ComparisonType.YearsOfService;
        empList.Sort(c);

        for (int i = 0; i < empList.Count; i++) {
            Console.Write("\n{0} ", empList[i].ToString());
        }
        Console.WriteLine("\n");
    }
}
```

## Output

```console
ID: 101. Years of Svc: 16
ID: 103. Years of Svc: 6
ID: 102. Years of Svc: 11
ID: 100. Years of Svc: 15
ID: 103. Years of Svc: 17
ID: 100. Years of Svc: 15
ID: 101. Years of Svc: 16
ID: 102. Years of Svc: 11
ID: 103. Years of Svc: 17
ID: 103. Years of Svc: 6
ID: 103. Years of Svc: 6
ID: 102. Years of Svc: 11
ID: 100. Years of Svc: 15
ID: 101. Years of Svc: 16
ID: 103. Years of Svc: 17
```

- The first block is the `Employees` as added to the list, the second block is
  sorted by `empID` the third by `yearsOfSvc`

## Generic Queues

- A queue is a first-in, first-out (FIFO) collection
- Add items to the queue one at a time
- Remove items one at a time in the order they were added
- A queue is a good collection to use when managing a limited resource
- There are a limited number of bank clerks
- Customers are handled in the order in which they are received
- The `Queue` class has a number of member methods and properties, the most
  important of which are shown on the next slide

| Method or Property           | Purpose                                                                             |
| ---------------------------- | ----------------------------------------------------------------------------------- |
| Count                        | Public property that returns the number of elements in the Queue                    |
| Clear()                      | Removes all objects from the Queue                                                  |
| Contains()                   | Determines whether an element is in the Queue                                       |
| CopyTo()                     | Copies the Queue elements to an existing one-dimensional array                      |
| Dequeue()                    | Removes and returns the object at the beginning of the Queue                        |
| Enqueue()                    | Adds an object to the end of the Queue                                              |
| GetEnumerator()              | Returns an enumerator for the Queue                                                 |
| Peek()                       | Returns a reference to the object at the beginning of the Queue without removing it |
| ToArray()                    | Copies the elements to a new array                                                  |
| Queue methods and properties |                                                                                     |

- A Queue always returns items in the same order in which they were added

```cs
using System.Collections.Generic;
```

```cs
public class Tester {
    static void Main() {
        Queue<int> intQueue = new Queue<int>();
        // populate the Queue
        for (int i = 0; i < 5; i++) {
            intQueue.Enqueue(i * 5);
        }

        // Display the Queue.
        Console.Write("intQueue values:\t");
        PrintValues(intQueue);

        // Remove an element from the Queue.
        Console.WriteLine("\n(Dequeue)\t{0}", intQueue.Dequeue());

        // Display the Queue.
        Console.Write("intQueue values:\t");
        PrintValues(intQueue);

        // Remove another element from the Queue.
        Console.WriteLine("\n(Dequeue)\t{0}", intQueue.Dequeue());

        // Display the Queue.
        Console.Write("intQueue values:\t");
        PrintValues(intQueue);

        // View the first element in the
        // Queue but do not remove.
        Console.WriteLine("\n(Peek) \t{0}", intQueue.Peek());

        // Display the Queue.
        Console.Write("intQueue values:\t");
        PrintValues(intQueue);
    }

    public static void PrintValues(IEnumerable<int> myCollection) {
        IEnumerator<int> myEnumerator = myCollection.GetEnumerator();

        while (myEnumerator.MoveNext()) {
            Console.Write("{0} ", myEnumerator.Current);
        }
        Console.WriteLine();
    }
}
```

## Output

```console
intQueue values: 0 5 10 15 20
    (Dequeue) 0
intQueue values: 5 10 15 20
    (Dequeue) 5
intQueue values: 10 15 20
    (Peek) 10
intQueue values: 10 15 20
```

- Although this example doesn't use the `Employee` class, user-defined objects
  can be enqueued as well
- `Queuing()` an object adds it to the `Queue` and `Dequeue()` returns the
  object as well as removes it from the `Queue`
- The `Queue` class also provides a `Peek()` method that allows the next element
  to be seen, but not removed
- Because the `Queue` class is enumerable, it can be passed to the
  `PrintValues()` method which takes an `IEnumerable` interface
- The conversion is implicit
- The `GetEnumerator()` method is required by all `IEnumerable` classes
- `GetEnumerator()` returns an `IEnumerator` which is used to enumerate all the
  objects in the collection
- `MoveNext()` is a method of `IEnumerator` which is used to retrieve the next
  value
- Current is the property of `IEnumerator` that represents the current value so
  the current value in the queue can be outputted by using
  `myEnumerator.Current`
- When there are no more values in the collection, `MoveNext()` returns `false`
  which ends the `while` loop
- It would be more likely to use a `foreach` loop instead

## Generic Stacks

- The `Stack` is the natural partner of the `Queue`
- A stack is a last-in, first-out (LIFO) collection, so the items are removed in
  the opposite order in which they were added
- Similar to the cafeteria plate loader
- Add a plate to the top of the stack
- That's the first plate removed
- The principle methods for adding and removing from a stack are `Push()` and
  `Pop()`
- Similar to the `Queue`, there is also a `Peek()` method

| Method or Property | Purpose                                                        |
| ------------------ | -------------------------------------------------------------- |
| Count              | Public property that gets the number of elements in the Stack  |
| Clear()            | Removes all objects from the Stack                             |
| Contains()         | Determines whether an element is in the Stack                  |
| CopyTo()           | Copies the Stack elements to an existing one-dimensional array |
| GetEnumerator()    | Returns an enumerator for the Stack                            |
| Peek()             | Returns the object at the top of the Stack without removing it |
| Pop()              | Removes and returns the object at the top of the Stack         |
| Push()             | Inserts an object at the top of the Stack                      |
| ToArray()          | Copies the elements to a new array                             |

## Stack methods and properties

- `Stack`s are similar to `Queue`s, but items are removed in the reverse order
  in which they were added

```cs
public class Tester {
    static void Main() {
        Stack<int> intStack = new Stack<int>();
        // populate the Stack
        for (int i = 0; i < 8; i++) {
            intStack.Push(i * 5);
        }

        // Display the Stack
        Console.Write("intStack values:\t");
        PrintValues(intStack);

        // Remove an element from the Stack
        Console.WriteLine("\n(Pop)\t{0}", intStack.Pop());

        // Display the Stack
        Console.Write("intStack values:\t");
        PrintValues(intStack);

        // Remove another element from the Stack
        Console.WriteLine("\n(Pop)\t{0}", intStack.Pop());

        // Display the Stack
        Console.Write("intStack values:\t");
        PrintValues(intStack);

        // View the first element in the
        // Stack but do not remove
        Console.WriteLine("\n(Peek) \t{0}", intStack.Peek());

        // Display the Stack
        Console.Write("intStack values:\t");
        PrintValues(intStack);

        // Declare an array object which will
        // hold 12 integers
        int[] targetArray = new int[12];
        for (int i = 0; i < targetArray.Length; i++) {
            targetArray[i] = i * 100 + 100;
        }

        // Display the values of the target Array instance
        Console.WriteLine("\nTarget array: ");
        PrintValues(targetArray);

        // Copy the entire source Stack to the
        // target Array instance, starting at index 6
        intStack.CopyTo(targetArray, 6);

        // Display the values of the target Array instance
        Console.WriteLine("\nTarget array after copy: ");
        PrintValues(targetArray);
    }

    public static void PrintValues(IEnumerable<int> myCollection) {
        Ienumerator<int> enumerator = myCollection.GetEnumerator();
        while (enumerator.MoveNext()) {
            Console.Write("{0} ", enumerator.Current);
        }
        Console.WriteLine();
    }
}
```

## Output

```console
intStack values:
    35 30 25 20 15 10 5 0
    (Pop) 35
intStack values:
    30 25 20 15 10 5 0
    (Pop) 30
intStack values:
    25 20 15 10 5 0
    (Peek) 25
intStack values:
    25 20 15 10 5 0
Target array:
    100 200 300 400 500 600 700 800 900 1000 1100 1200
Target array after copy:
    100 200 300 400 500 600 25 20 15 10 5 0
```

- The effect of `CopyTo()` can be seen by examining the target array before and
  after it's called
- Elements are overwritten starting at the index specified (6)

## Dictionaries

- A dictionary is a collection that associates a key with a value
- It uses a non-numeric index
- A language dictionary associates a word (the key) with its definition (the
  value)
- Assume a list of the provincial capitals
- One approach might be to put them into an array:

```cs
string[] provCapitals = new string[13];
```

- The `provCapitals` array will hold 13 capital cities
- Each capital is accessed by an index into the array:

```cs
string capitalOfOntario = provCapitals[9];
```

- It is inconvenient to access capitals using array notation
- There's no easy way to determine that Ontario is the 9th province
  alphabetically
- Convenient to store the capital with the province name
- A dictionary allows a value (capital) to be stored with a key (province)
- A .NET Framework dictionary can associate any kind of key (string, int, or
  object) with any kind of value (string, int, or object)
- Typically the key is fairly short and the value fairly complex

| Method or Property | Purpose                                                                        |
| ------------------ | ------------------------------------------------------------------------------ |
| Count              | Public property that gets the number of elements in the Dictionary             |
| Item               | The indexer for the Dictionary                                                 |
| Keys               | Public property that gets a collection containing the keys in the Dictionary   |
| Values             | Public property that gets a collection containing the values in the Dictionary |
| Add()              | Adds an entry with a specified Key and Value                                   |
| Clear()            | Removes all objects from the Dictionary                                        |
| ContainsKey()      | Determines whether the Dictionary has a specified key                          |
| ContainsValue()    | Determines whether the Dictionary has a specified value                        |
| GetEnumerator()    | Returns an enumerator for the Dictionary                                       |
| Remove()           | Removes the entry with the specified Key                                       |

- Most important attributes of a good dictionary are that it is easy to add
  values and it is quick to retrieve values
- The key in a `Dictionary` can be a primitive key, or it can be an instance of
  a user-defined type
- Objects used as keys must implement the method `GetHashCode()` as well as
  `Equals()`
- This is how the `Dictionary` works behind the scenes
- There is actually a numeric index assigned to the value, but that index is
  associated with the key, no need to ever know what it is
- `GetHashCode()` is so fundamental that it's actually implemented in Object
- In most cases, the inherited method can just be used
- Dictionaries implement the interface `IDictionary<TKey, TValue>`
- `IDictionary` provides a public property, `Item`, that retrieves a value with
  the specified key
- The `Item` property is implemented with the index operator (`[]`)
- Access items in any `Dictionary` object using the same syntax as an array
- A dictionary called addresses might hold the addresses of various businesses
  with the company name as the key
- Access the Office address like this: addresses["Office"]
- The `Dictionary` collection uses nonnumeric indexers

```cs
public class Tester {
    static void Main() {
        Dictionary<string, string> dict = new Dictionary<string, string>();
        dict.Add("Alberta", "Edmonton");
        dict.Add("British Columbia", "Victoria");
        dict.Add("Manitoba", "Winnipeg");
        dict.Add("New Brunswick", "Fredericton");
        dict.Add("Newfoundland", "St. John's");
        dict.Add("Northwest Territories", "Yellowknife");
        dict.Add("Nova Scotia", "Halifax");
        dict.Add("Nunavut", "Iqaluit");
        dict.Add("Ontario", "Toronto");
        dict.Add("Prince Edward Island", "Charlottetown");
        dict.Add("Quebec", "Quebec City");
        dict.Add("Saskatchewan", "Regina");
        dict.Add("Yukon", "Whitehorse");

        Console.WriteLine("The capital of Ontario is {0}", dict["Ontario"]);
    }
}
```

## Output

```console
The capital of Ontario is Toronto
```

- This example begins by instantiating a new `Dictionary` object with the type
  of the key and the value declared to be a string
- Then 13 key/value pairs were added
- In this example, the province name is the key and the capital is the value
- The value of the key object must not be changed once used in a dictionary

- If a collection is modified after an enumerator is created for that
  collection, the enumerator immediately becomes invalid, for this reason,
  enumerators are said to be "fail fast".
- "Any calls to the enumerator's Reset or `MoveNext` methods after this point
  throw `InvalidOperationExceptions`.
- This is true for collections, but not for arrays.
- The load factor in a hash table is a classic example of a space-time
  trade-off:
- By increasing the load factor, we get better memory utilization, but the app
  runs slower due to increased hashing collisions.
- By decreasing the load factor, we get better speed because of reduced hashing
  collisions, but we get poorer memory utilization because a larger portion of
  the hash table remains empty.
- Because class `SortedDictionary` keeps its elements sorted in a binary tree,
  obtaining or inserting a key-val pair takes $O(log(n))$ time, which is fast
  compared to linear searching, then inserting.
- Using the `Add` method to add a key that already exists in the hash table
  causes an `ArgumentException`.
- Invoking the get accessor of a `SortedDictionary` indexer with a key that does
  not exist in the collection causes a `KeyNotFoundException`.
- For maximal code reuse, define methods with generic type parameters whenever
  possible.
